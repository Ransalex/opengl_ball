//+------------------------------------------------------------------+
//|                                                   Scyforge test |
//|                                                            2014 |
//+------------------------------------------------------------------+
#pragma once

namespace math
{
   //+------------------------------------------------------------------+
   //| Базовый класс вектора
   //+------------------------------------------------------------------+
   template <typename T, const int len> class vecN
   {
   protected:
      typedef class vecN<T,len> my_type;
      typedef T element_type;

      T data[len];

   public:
                vecN() { ZeroMemory(data, sizeof(data)); }
               ~vecN() {}
      //+------------------------------------------------------------------+
      //| Конструктор копирования
      //+------------------------------------------------------------------+
      vecN(const vecN& that)
      {
         assign(that);
      }
      //+------------------------------------------------------------------+
      //| Конструктор из скалярного значения
      //+------------------------------------------------------------------+
      vecN(T s)
      {
         for (int i = 0; i < len; i++)
         {
            data[i] = s;
         }
      }
      //+------------------------------------------------------------------+
      //| Присваивание
      //+------------------------------------------------------------------+
      vecN& operator=(const vecN& that)
      {
         assign(that);
         return(*this);
      }
      //+------------------------------------------------------------------+
      //| Сложение
      //+------------------------------------------------------------------+
      vecN operator+(const vecN& that) const
      {
         my_type result;
      
         for (int i = 0; i < len; ++i)
            result.data[i] = data[i] + that.data[i];

         return(result);
      }
      //+------------------------------------------------------------------+
      //| Вычитание
      //+------------------------------------------------------------------+
      vecN operator-(const vecN& that) const
      {
         my_type result;
      
         for (int i = 0; i < len; ++i)
            result.data[i] = data[i] - that.data[i];

         return(result);
      }
      //+------------------------------------------------------------------+
      //| Вычитание
      //+------------------------------------------------------------------+
      vecN& operator-=(const vecN& that)
      {
         return(*this = *this - that);
      }
      //+------------------------------------------------------------------+
      //| Обратный вектор
      //+------------------------------------------------------------------+
      vecN operator-() const
      {
         my_type result;

         for(int i = 0; i < len; ++i)
            result.data[i] = -data[i];

         return(result);
      }
      //+------------------------------------------------------------------+
      //| Умножение
      //+------------------------------------------------------------------+
      vecN operator*(const vecN& that) const
      {
         my_type result;

         for (i = 0; i < len; ++i)
            result.data[i] = data[i] * that.data[i];

         return(result);
      }
      //+------------------------------------------------------------------+
      //| Умножение на скаляр
      //+------------------------------------------------------------------+
      vecN operator*(const T& that) const
      {
         my_type result;

         for (i = 0; i < len; ++i)
            result.data[i] = data[i] * that;

         return(result);
      }
      //+------------------------------------------------------------------+
      //| Деление на скаляр
      //+------------------------------------------------------------------+
      vecN operator/(const T& that) const
      {
         my_type result;

         for(int i = 0; i < len; ++i)
            result.data[i] = data[i] / that;

         return result;
      }
      //+------------------------------------------------------------------+
      //| Оператор доступа
      //+------------------------------------------------------------------+
      T& operator[](int n)
      {
         return(data[n]);
      }
      //+------------------------------------------------------------------+
      //| Оператор доступа
      //+------------------------------------------------------------------+
      const T& operator[](int n) const
      {
         return(data[n]);
      }
      //+------------------------------------------------------------------+
      //| Размер
      //+------------------------------------------------------------------+
      static int size()
      {
         return(len);
      }
      //+------------------------------------------------------------------+
      //| Приведение к указателю
      //+------------------------------------------------------------------+
      operator const T* () const
      {
         return(&data[0]);
      }

   protected:   
      //+------------------------------------------------------------------+
      //| Присвоение значений
      //+------------------------------------------------------------------+
      void assign(const vecN& that)
      {
         for(int i = 0; i < len; ++i)
            data[i] = that.data[i];
      }
   };

   //+------------------------------------------------------------------+
   //| Вектор 3
   //+------------------------------------------------------------------+
   template <typename T> class Tvec3 : public vecN<T,3>
   {
   public:
      typedef vecN<T,3> base;

      Tvec3() {}
      //+------------------------------------------------------------------+
      //| Конструктор
      //+------------------------------------------------------------------+
       Tvec3(const base& v) : base(v) {}
      //+------------------------------------------------------------------+
      //| Конструктор
      //+------------------------------------------------------------------+
      Tvec3(T x, T y, T z)
      {
         base::data[0] = x;
         base::data[1] = y;
         base::data[2] = z;
      }

   };
   //+------------------------------------------------------------------+
   //| Вектор 4
   //+------------------------------------------------------------------+
   template <typename T> class Tvec4 : public vecN<T,4>
   {
   public:
      typedef vecN<T,4> base;

      Tvec4(){}
      Tvec4(const base& v) : base(v) {}
      //+------------------------------------------------------------------+
      //| Конструктор
      //+------------------------------------------------------------------+
      Tvec4(T x, T y, T z, T w)
      {
         base::data[0] = x;
         base::data[1] = y;
         base::data[2] = z;
         base::data[3] = w;
      }

      //+------------------------------------------------------------------+
      //| Конструктор
      //+------------------------------------------------------------------+
      Tvec4(const Tvec3<T>& v, T w)
      {
         base::data[0] = v[0];
         base::data[1] = v[1];
         base::data[2] = v[2];
         base::data[3] = w;
      }
      //+------------------------------------------------------------------+
      //| Конструктор
      //+------------------------------------------------------------------+
      Tvec4(T x, const Tvec3<T>& v)
      {
         base::data[0] = x;
         base::data[1] = v[0];
         base::data[2] = v[1];
         base::data[3] = v[2];
      }
   };
   //+------------------------------------------------------------------+
   //| Базовый класс матрицы
   //+------------------------------------------------------------------+
   template <typename T, const int w, const int h> class matNM
   {
   protected:
      typedef class matNM<T,w,h> my_type;
      typedef class vecN<T,h> vector_type;

      vecN<T,h> data[w];

   public:
   
      matNM() {}
      //+------------------------------------------------------------------+
      //| Конструктор копирования
      //+------------------------------------------------------------------+
      matNM(const matNM& that)
      {
         assign(that);
      }
      //+------------------------------------------------------------------+
      //| Конструктор копирования из скаляра, запрещаем присваивание
      //+------------------------------------------------------------------+
      explicit matNM(T f)
      {
         for(int i = 0; i < w; ++i)
         {
            data[i] = f;
         }
      }
      //+------------------------------------------------------------------+
      //| Присваивание
      //+------------------------------------------------------------------+
      matNM& operator=(const my_type& that)
      {
         assign(that);
         return(*this);
      }
      //+------------------------------------------------------------------+
      //| Сложение
      //+------------------------------------------------------------------+
      matNM operator+(const my_type& that) const
      {
         my_type result;

         for(int i = 0; i < w; ++i)
            result.data[i] = data[i] + that.data[i];

         return(result);
      }
      //+------------------------------------------------------------------+
      //| Сложение
      //+------------------------------------------------------------------+
      my_type& operator+=(const my_type& that)
      {
         return(*this = *this + that);
      }
      //+------------------------------------------------------------------+
      //| Вычитание
      //+------------------------------------------------------------------+
      my_type operator-(const my_type& that) const
      {
         my_type result;

         for(int i = 0; i < w; ++i)
            result.data[i] = data[i] - that.data[i];

         return(result);
      }
      //+------------------------------------------------------------------+
      //| Вычитание
      //+------------------------------------------------------------------+
      my_type& operator-=(const my_type& that)
      {
         return(*this = *this - that);
      }
      //+------------------------------------------------------------------+
      //| Умножение на скаляр
      //+------------------------------------------------------------------+
      my_type operator*(const T& that) const
      {
         my_type result;
      
         for(int i = 0; i < w; ++i)
            result.data[i] = data[i] * that;

         return(result);
      }
      //+------------------------------------------------------------------+
      //| Умножение квадратных матриц 
      //+------------------------------------------------------------------+
      my_type operator*(const my_type& that) const
      {
         my_type result(0);

         for(int j = 0; j < w; ++j)
         {
            for(int i = 0; i < h; ++i)
            {
               T sum(0);
               for(int n = 0; n < w; ++n)
               {
                  sum += data[n][i] * that[j][n];
               }
               result[j][i] = sum;
            }
         }

         return(result);
      }
      //+------------------------------------------------------------------+
      //| Оператор доступа
      //+------------------------------------------------------------------+
      vector_type& operator[](int n)
      {
         return(data[n]);
      }
      //+------------------------------------------------------------------+
      //| Оператор доступа
      //+------------------------------------------------------------------+
      const vector_type& operator[](int n) const
      {
         return(data[n]);
      }
      //+------------------------------------------------------------------+
      //| Приведение к указателю
      //+------------------------------------------------------------------+
      operator T*()
      {
         return(&data[0][0]);
      }
      //+------------------------------------------------------------------+
      //| Приведение к указателю
      //+------------------------------------------------------------------+
      operator const T*() const
      {
         return(&data[0][0]);
      }
      //+------------------------------------------------------------------+
      //| Обратная матрица
      //+------------------------------------------------------------------+
      matNM<T,h,w> transpose(void) const
      {
         matNM<T,h,w> result;
         int x, y;

         for (y = 0; y < w; ++y)
         {
            for (x = 0; x < h; ++x)
            {
               result[x][y] = data[y][x];
            }
         }

         return(result);
      }
      //+------------------------------------------------------------------+
      //| Единичная матрица
      //+------------------------------------------------------------------+
      static my_type identity()
      {
         my_type result(0);

         for (int i = 0; i < w; ++i)
         {
            result[i][i] = 1;
         }

         return(result);
      }
      //+------------------------------------------------------------------+
      //| Ширина
      //+------------------------------------------------------------------+
      static int width()
      {
      return(w);
      }
      //+------------------------------------------------------------------+
      //| Высота
      //+------------------------------------------------------------------+
      static int height()
      {
      return(h);
      }

   protected:
      //+------------------------------------------------------------------+
      //| Присвоение значений
      //+------------------------------------------------------------------+
      void assign(const matNM& that)
      {
         for (int i = 0; i < w; ++i)
            data[i] = that.data[i];
      }
   };

   //+------------------------------------------------------------------+
   //| Матрица 4x4
   //+------------------------------------------------------------------+
   template <typename T>
   class Tmat4 : public matNM<T,4,4>
   {
   public:
      typedef matNM<T,4,4> base;
      typedef Tmat4<T> my_type;

      //+------------------------------------------------------------------+
      //| Конструктор
      //+------------------------------------------------------------------+
      Tmat4() {}
      //+------------------------------------------------------------------+
      //| Конструктор
      //+------------------------------------------------------------------+
      Tmat4(const my_type& that) : base(that) {}
      //+------------------------------------------------------------------+
      //| Конструктор
      //+------------------------------------------------------------------+
      Tmat4(const base& that) : base(that) {}
      //+------------------------------------------------------------------+
      //| Конструктор
      //+------------------------------------------------------------------+
      Tmat4(const vecN<T,4>& v) : base(v) {}
      //+------------------------------------------------------------------+
      //| Конструктор
      //+------------------------------------------------------------------+
      Tmat4(const vecN<T,4>& v0,
         const vecN<T,4>& v1,
         const vecN<T,4>& v2,
         const vecN<T,4>& v3)
      {
         base::data[0] = v0;
         base::data[1] = v1;
         base::data[2] = v2;
         base::data[3] = v3;
      }
   };

   typedef Tvec4<float> vec4;
   typedef Tvec3<float> vec3;
   typedef Tmat4<float> mat4;
   //+------------------------------------------------------------------+
   //| Векторное произведение
   //+------------------------------------------------------------------+
   template <typename T> static vecN<T,3> cross(const vecN<T,3>& a, const vecN<T,3>& b)
   {
      return(Tvec3<T>(a[1] * b[2] - b[1] * a[2],
         a[2] * b[0] - b[2] * a[0],
         a[0] * b[1] - b[0] * a[1]));
   }
   //+------------------------------------------------------------------+
   //| Длина вектора
   //+------------------------------------------------------------------+
   template <typename T, int len> static T length(const vecN<T,len>& v)
   {
      T result(0);

      for (int i = 0; i < v.size(); ++i)
      {
         result += v[i] * v[i];
      }

      return((T)sqrt(result));
   }
   //+------------------------------------------------------------------+
   //| Нормализация вектора
   //+------------------------------------------------------------------+
   template <typename T, int len> static vecN<T,len> normalize(const vecN<T,len>& v)
   {
      return(v/length(v));
   }
   //+------------------------------------------------------------------+
   //| Перевод градусов в радианы
   //+------------------------------------------------------------------+
   template <typename T> T radians(T angleInDegrees)
   {
      return(angleInDegrees * static_cast<T>(M_PI/180.0));
   }
   //+------------------------------------------------------------------+
   //| Создание матрицы перспективы
   //+------------------------------------------------------------------+
   static mat4 perspective(float fovy, float aspect, float n, float f)
   {
      float q = 1.0f / tan(radians(0.5f * fovy));
      float A = q / aspect;
      float B = (n + f) / (n - f);
      float C = (2.0f * n * f) / (n - f);

      mat4 result;

      result[0] = vec4(A, 0.0f, 0.0f, 0.0f);
      result[1] = vec4(0.0f, q, 0.0f, 0.0f);
      result[2] = vec4(0.0f, 0.0f, B, -1.0f);
      result[3] = vec4(0.0f, 0.0f, C, 0.0f);

      return(result);
   }
   //+------------------------------------------------------------------+
   //| Создание матрицы frustum
   //+------------------------------------------------------------------+
   static mat4 frustum(float left, float right, float bottom, float top, float n, float f)
   {
      mat4 result(mat4::identity());

      if ((right == left) ||(top == bottom) || (n == f) || (n < 0.0) || (f < 0.0)) return(result);
     
      result[0][0] = (2.0f * n)/(right - left);
      result[1][1] = (2.0f * n)/(top - bottom);

      result[2][0] = (right + left)/(right - left);
      result[2][1] = (top + bottom)/(top - bottom);
      result[2][2] = -(f + n)/(f - n);
      result[2][3]= -1.0f;

      result[3][2] = -(2.0f * f * n)/(f - n);
      result[3][3] =  0.0f;

      return(result);
   }
   //+------------------------------------------------------------------+
   //| Создание матрицы перемещения
   //+------------------------------------------------------------------+
   template <typename T> static Tmat4<T> translate(T x, T y, T z)
   {
      return(Tmat4<T>(Tvec4<T>(1.0f, 0.0f, 0.0f, 0.0f),
         Tvec4<T>(0.0f, 1.0f, 0.0f, 0.0f),
         Tvec4<T>(0.0f, 0.0f, 1.0f, 0.0f),
         Tvec4<T>(x, y, z, 1.0f)));
   }
   //+------------------------------------------------------------------+
   //|Создание матрицы перемещения
   //+------------------------------------------------------------------+
   template <typename T> static Tmat4<T> translate(const vecN<T,3>& v)
   {
      return(translate(v[0], v[1], v[2]));
   }
   //+------------------------------------------------------------------+
   //|Создание матрицы поворота
   //+------------------------------------------------------------------+
   template <typename T> static Tmat4<T> rotate(T angle, T x, T y, T z)
   {
      Tmat4<T> result;

      const T     x2   =x * x;
      const T     y2   =y * y;
      const T     z2   =z * z;
      float       rads =float(angle) * 0.0174532925f;
      const float c    =cosf(rads);
      const float s    =sinf(rads);
      const float omc  =1.0f - c;

      result[0] = Tvec4<T>(T(x2 * omc + c), T(y * x * omc + z * s), T(x * z * omc - y * s), T(0));
      result[1] = Tvec4<T>(T(x * y * omc - z * s), T(y2 * omc + c), T(y * z * omc + x * s), T(0));
      result[2] = Tvec4<T>(T(x * z * omc + y * s), T(y * z * omc - x * s), T(z2 * omc + c), T(0));
      result[3] = Tvec4<T>(T(0), T(0), T(0), T(1));

      return(result);
   }
   //+------------------------------------------------------------------+
   //| Создание матрицы направления
   //+------------------------------------------------------------------+
   template <typename T> Tmat4<T>lookat(const vecN<T,3>& eye, const vecN<T,3>& center, const vecN<T,3>& up)
   {
      const Tvec3<T> f = normalize(center - eye);
      const Tvec3<T> upN = normalize(up);
      const Tvec3<T> s = cross(f, upN);
      const Tvec3<T> u = cross(s, f);
      const Tmat4<T> M = Tmat4<T>(Tvec4<T>(s[0], u[0], -f[0], T(0)),
         Tvec4<T>(s[1], u[1], -f[1], T(0)),
         Tvec4<T>(s[2], u[2], -f[2], T(0)),
         Tvec4<T>(T(0), T(0), T(0), T(1)));

      return(M * translate<T>(-eye));
   }

   template <typename T, const int N, const int M> vecN<T,N> operator*(const vecN<T,M>& vec, const matNM<T,N,M>& mat)
   {
      int n, m;
      vecN<T,N> result(T(0));

      for (m = 0; m < M; m++)
      {
         for (n = 0; n < N; n++)
         {
            result[n] += vec[m] * mat[n][m];
         }
      }

      return result;
   }

   template <typename T, int len> T dot(const vecN<T,len>& a, const vecN<T,len>& b)
   {
      T total = T(0);

      for(int i = 0; i < len; i++)
      {
         total += a[i] * b[i];
      }
      return total;
   }
};