//+------------------------------------------------------------------+
//|                                                   Scyforge test |
//|                                                            2014 |
//+------------------------------------------------------------------+
#pragma once
//+------------------------------------------------------------------+
//|Класс для автоматического удаления выделенной памяти 
//+------------------------------------------------------------------+
template <typename T>
class CSmartPtr
{
private:
   T *m_pntr;

public:
   //+------------------------------------------------------------------+
   //| Конструкторы                                                     
   //+------------------------------------------------------------------+
   CSmartPtr()        : m_pntr(NULL) {}
   CSmartPtr(T *pntr) : m_pntr(pntr) {}
   //+------------------------------------------------------------------+
   //| Деструктор                                                       
   //+------------------------------------------------------------------+
   ~CSmartPtr()
   {
      if(m_pntr) { delete m_pntr; m_pntr=NULL; }
   }
   //+------------------------------------------------------------------+
   //| Операторы                                                        
   //+------------------------------------------------------------------+
   operator          T*()                 { return(m_pntr);  }
   T*                operator -> ()       { return(m_pntr);  }
   const T*          operator -> () const { return(m_pntr);  }
   T**               operator &  ()       { return(&m_pntr); }
   CSmartPtr& operator=(T* pntr)
   {
      if(pntr!=m_pntr)
      {
         if(m_pntr!=NULL)
            delete m_pntr;

         m_pntr=pntr;
      }

      return(*this);
     }
   //+------------------------------------------------------------------+
   //| Открепить указатель 
   //+------------------------------------------------------------------+
   T* detach()
   {
      T* temp=m_pntr;
      m_pntr=NULL;
      return(temp);
   }
   //+------------------------------------------------------------------+
   //| Получить указаетль 
   //+------------------------------------------------------------------+
   T* pointer()
   {
      return(m_pntr);
   }
};
//+------------------------------------------------------------------+
//| Класс для автоматического удаления выделенной памяти             
//+------------------------------------------------------------------+
template <typename T>
class CSmartArray
  {
private:
   T *m_pntr;

public:
   //+------------------------------------------------------------------+
   //| Конструкторы                                                     
   //+------------------------------------------------------------------+
   CSmartArray()        : m_pntr(NULL) {}
   CSmartArray(T *pntr) : m_pntr(pntr) {}
   //+------------------------------------------------------------------+
   //| Деструктор                                                       
   //+------------------------------------------------------------------+
   ~CSmartArray()
   {
      if(m_pntr) { delete[] m_pntr; m_pntr=NULL; }
   }
   //+------------------------------------------------------------------+
   //| Операторы                                                        
   //+------------------------------------------------------------------+
   operator          T*()                 { return(m_pntr);  }
   T*                operator -> ()       { return(m_pntr);  }
   const T*          operator -> () const { return(m_pntr);  }
   T**               operator &  ()       { return(&m_pntr); }
   CSmartArray& operator=(T* pntr)
   {
      if(pntr!=m_pntr)
      {
         if(m_pntr!=NULL) delete[] m_pntr;
         m_pntr=pntr;
      }
      //---
      return(*this);
   }
   //+------------------------------------------------------------------+
   //| Функции                                                          
   //+------------------------------------------------------------------+
   T* detach()
   {
      T* temp=m_pntr;
      m_pntr=NULL;
      return(temp);
   }
   //+------------------------------------------------------------------+
   //| Получить указаетль 
   //+------------------------------------------------------------------+
   T* pointer()
     {
      return(m_pntr);
     }
   //+------------------------------------------------------------------+
   //| Получить указаетль 
   //+------------------------------------------------------------------+
   const T* Pointer() const
   {
      return(m_pntr);
   }
};